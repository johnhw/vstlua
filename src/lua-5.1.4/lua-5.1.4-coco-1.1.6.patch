--- /dev/null	1970-01-01 01:00:00 +0100
+++ lua-5.1.4-coco/src/lcoco.c	2009-09-08 14:00:00 +0200
@@ -0,0 +1,693 @@
+/*
+** Copyright (C) 2004-2009 Mike Pall. All rights reserved.
+**
+** Permission is hereby granted, free of charge, to any person obtaining
+** a copy of this software and associated documentation files (the
+** "Software"), to deal in the Software without restriction, including
+** without limitation the rights to use, copy, modify, merge, publish,
+** distribute, sublicense, and/or sell copies of the Software, and to
+** permit persons to whom the Software is furnished to do so, subject to
+** the following conditions:
+**
+** The above copyright notice and this permission notice shall be
+** included in all copies or substantial portions of the Software.
+**
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**
+** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
+*/
+
+/* Coco -- True C coroutines for Lua. http://luajit.org/coco.html */
+#ifndef COCO_DISABLE
+
+#define lcoco_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "ldo.h"
+#include "lvm.h"
+#include "lgc.h"
+
+
+/*
+** Define this if you want to run Coco with valgrind. You will get random
+** errors about accessing memory from newly allocated C stacks if you don't.
+** You need at least valgrind 3.0 for this to work.
+**
+** This macro evaluates to a no-op if not run with valgrind. I.e. you can
+** use the same binary for regular runs, too (without a performance loss).
+*/
+#ifdef USE_VALGRIND
+#include <valgrind/valgrind.h>
+#define STACK_REG(coco, p, sz)	(coco)->vgid = VALGRIND_STACK_REGISTER(p, p+sz);
+#define STACK_DEREG(coco)	VALGRIND_STACK_DEREGISTER((coco)->vgid);
+#define STACK_VGID		unsigned int vgid;
+#else
+#define STACK_REG(coco, p, sz)
+#define STACK_DEREG(id)
+#define STACK_VGID
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+/* Use Windows Fibers. */
+#if defined(COCO_USE_FIBERS)
+
+#define _WIN32_WINNT 0x0400
+#include <windows.h>
+
+#define COCO_MAIN_DECL		CALLBACK
+
+typedef LPFIBER_START_ROUTINE coco_MainFunc;
+
+#define COCO_NEW(OL, NL, cstacksize, mainfunc) \
+  if ((L2COCO(NL)->fib = CreateFiber(cstacksize, mainfunc, NL)) == NULL) \
+    luaD_throw(OL, LUA_ERRMEM);
+
+#define COCO_FREE(L) \
+  DeleteFiber(L2COCO(L)->fib); \
+  L2COCO(L)->fib = NULL;
+
+/* See: http://blogs.msdn.com/oldnewthing/archive/2004/12/31/344799.aspx */
+#define COCO_JUMPIN(coco) \
+  { void *cur = GetCurrentFiber(); \
+    coco->back = (cur == NULL || cur == (void *)0x1e00) ? \
+      ConvertThreadToFiber(NULL) : cur; } \
+  SwitchToFiber(coco->fib);
+
+#define COCO_JUMPOUT(coco) \
+  SwitchToFiber(coco->back);
+
+/* CreateFiber() defaults to STACKSIZE from the Windows module .def file. */
+#define COCO_DEFAULT_CSTACKSIZE		0
+
+/* ------------------------------------------------------------------------ */
+
+#else /* !COCO_USE_FIBERS */
+
+#ifndef COCO_USE_UCONTEXT
+
+/* Try inline asm first. */
+#if __GNUC__ >= 3 && !defined(COCO_USE_SETJMP)
+
+#if defined(__i386) || defined(__i386__)
+
+#ifdef __PIC__
+typedef void *coco_ctx[4];  /* eip, esp, ebp, ebx */
+static inline void coco_switch(coco_ctx from, coco_ctx to)
+{
+  __asm__ __volatile__ (
+    "call 1f\n" "1:\tpopl %%eax\n\t" "addl $(2f-1b),%%eax\n\t"
+    "movl %%eax, (%0)\n\t" "movl %%esp, 4(%0)\n\t"
+    "movl %%ebp, 8(%0)\n\t" "movl %%ebx, 12(%0)\n\t"
+    "movl 12(%1), %%ebx\n\t" "movl 8(%1), %%ebp\n\t"
+    "movl 4(%1), %%esp\n\t" "jmp *(%1)\n" "2:\n"
+    : "+S" (from), "+D" (to) : : "eax", "ecx", "edx", "memory", "cc");
+}
+#else
+typedef void *coco_ctx[3];  /* eip, esp, ebp */
+static inline void coco_switch(coco_ctx from, coco_ctx to)
+{
+  __asm__ __volatile__ (
+    "movl $1f, (%0)\n\t" "movl %%esp, 4(%0)\n\t" "movl %%ebp, 8(%0)\n\t"
+    "movl 8(%1), %%ebp\n\t" "movl 4(%1), %%esp\n\t" "jmp *(%1)\n" "1:\n"
+    : "+S" (from), "+D" (to) : : "eax", "ebx", "ecx", "edx", "memory", "cc");
+}
+#endif
+
+#define COCO_CTX		coco_ctx
+#define COCO_SWITCH(from, to)	coco_switch(from, to);
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  buf[0] = (void *)(func); \
+  buf[1] = (void *)(stack); \
+  buf[2] = (void *)0; \
+  stack[0] = 0xdeadc0c0;  /* Dummy return address. */ \
+  coco->arg0 = (size_t)(a0);
+#define COCO_STATE_HEAD		size_t arg0;
+
+#elif defined(__x86_64__)
+
+static void coco_wrap_main(void)
+{
+  __asm__ __volatile__ ("\tmovq %r13, %rdi\n\tjmpq *%r12\n");
+}
+
+typedef void *coco_ctx[8];  /* rip, rsp, rbp, rbx, r12, r13, r14, r15 */
+static inline void coco_switch(coco_ctx from, coco_ctx to)
+{
+  __asm__ __volatile__ (
+    "leaq 1f(%%rip), %%rax\n\t"
+    "movq %%rax, (%0)\n\t" "movq %%rsp, 8(%0)\n\t" "movq %%rbp, 16(%0)\n\t"
+    "movq %%rbx, 24(%0)\n\t" "movq %%r12, 32(%0)\n\t" "movq %%r13, 40(%0)\n\t"
+    "movq %%r14, 48(%0)\n\t" "movq %%r15, 56(%0)\n\t"
+    "movq 56(%1), %%r15\n\t" "movq 48(%1), %%r14\n\t" "movq 40(%1), %%r13\n\t"
+    "movq 32(%1), %%r12\n\t" "movq 24(%1), %%rbx\n\t" "movq 16(%1), %%rbp\n\t"
+    "movq 8(%1), %%rsp\n\t" "jmpq *(%1)\n" "1:\n"
+    : "+S" (from), "+D" (to) :
+    : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory", "cc");
+}
+
+#define COCO_CTX		coco_ctx
+#define COCO_SWITCH(from, to)	coco_switch(from, to);
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  buf[0] = (void *)(coco_wrap_main); \
+  buf[1] = (void *)(stack); \
+  buf[2] = (void *)0; \
+  buf[3] = (void *)0; \
+  buf[4] = (void *)(func); \
+  buf[5] = (void *)(a0); \
+  buf[6] = (void *)0; \
+  buf[7] = (void *)0; \
+  stack[0] = 0xdeadc0c0deadc0c0;  /* Dummy return address. */ \
+
+#elif __mips && _MIPS_SIM == _MIPS_SIM_ABI32 && !defined(__mips_eabi)
+
+/* No way to avoid the function prologue with inline assembler. So use this: */
+static const unsigned int coco_switch[] = {
+#ifdef __mips_soft_float
+#define COCO_STACKSAVE		-10
+  0x27bdffd8,  /* addiu sp, sp, -(10*4) */
+#else
+#define COCO_STACKSAVE		-22
+  0x27bdffa8,  /* addiu sp, sp, -(10*4+6*8) */
+  /* sdc1 {$f20-$f30}, offset(sp) */
+  0xf7be0050, 0xf7bc0048, 0xf7ba0040, 0xf7b80038, 0xf7b60030, 0xf7b40028,
+#endif
+  /* sw {gp,s0-s8}, offset(sp) */
+  0xafbe0024, 0xafb70020, 0xafb6001c, 0xafb50018, 0xafb40014, 0xafb30010,
+  0xafb2000c, 0xafb10008, 0xafb00004, 0xafbc0000,
+  /* sw sp, 4(a0); sw ra, 0(a0); lw ra, 0(a1); lw sp, 4(a1); move t9, ra */
+  0xac9d0004, 0xac9f0000, 0x8cbf0000, 0x8cbd0004, 0x03e0c821,
+  /* lw caller-saved-reg, offset(sp) */
+  0x8fbe0024, 0x8fb70020, 0x8fb6001c, 0x8fb50018, 0x8fb40014, 0x8fb30010,
+  0x8fb2000c, 0x8fb10008, 0x8fb00004, 0x8fbc0000,
+#ifdef __mips_soft_float
+  0x03e00008, 0x27bd0028  /* jr ra; addiu sp, sp, 10*4 */
+#else
+  /* ldc1 {$f20-$f30}, offset(sp) */
+  0xd7be0050, 0xd7bc0048, 0xd7ba0040, 0xd7b80038, 0xd7b60030, 0xd7b40028,
+  0x03e00008, 0x27bd0058  /* jr ra; addiu sp, sp, 10*4+6*8 */
+#endif
+};
+
+typedef void *coco_ctx[2];  /* ra, sp */
+#define COCO_CTX		coco_ctx
+#define COCO_SWITCH(from, to) \
+  ((void (*)(coco_ctx, coco_ctx))coco_switch)(from, to);
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  buf[0] = (void *)(func); \
+  buf[1] = (void *)&stack[COCO_STACKSAVE]; \
+  stack[4] = (size_t)(a0);  /* Assumes o32 ABI. */
+#define COCO_STACKADJUST	8
+#define COCO_MAIN_PARAM		int _a, int _b, int _c, int _d, lua_State *L
+
+#elif defined(__sparc__)
+
+typedef void *coco_ctx[4];
+#define COCO_CTX		coco_ctx
+#define COCO_SWITCH(from, to)	coco_switch(from, to);
+#define COCO_STACKADJUST	24
+
+#if defined(__LP64__)
+#define COCO_STACKBIAS		(2047UL)
+#define COCO_PTR2SP(stack)	(((unsigned long)stack)-COCO_STACKBIAS)
+static inline void coco_switch(coco_ctx from, coco_ctx to)
+{
+  void *__stack[16] __attribute__((aligned (16)));
+  unsigned long __tmp_sp = COCO_PTR2SP(__stack);
+  __asm__ __volatile__
+    (/* Flush register window(s) to stack and save the previous stack
+	pointer to capture the current registers, %l0-%l7 and %i0-%i7. */
+     "ta 3\n\t"
+     "stx %%sp,[%0+8]\n\t"
+     /* Move to a temporary stack. If the register window is flushed
+	for some reason (e.g. context switch), not the next stack
+	but the temporary stack should be used so as not to break
+	neither the previous nor next stack */
+     "mov %2,%%sp\n\t"
+     "sethi %%hh(1f),%%g1\n\t"		/* i.e. setx 1f,%%g1 */
+     "or %%g1,%%hm(1f),%%g1\n\t"
+     "sethi %%lm(1f),%%g2\n\t"
+     "or %%g2,%%lo(1f),%%g2\n\t"
+     "sllx %%g1,32,%%g1\n\t"
+     "or %%g1,%%g2,%%g1\n\t"
+     "stx %%g1,[%0]\n\t"
+     /* Restore registers from stack. DO NOT load the next stack
+	pointer directly to %sp. The register window can be possibly
+	flushed and restored asynchronous (e.g. context switch). */
+     "mov %1,%%o1\n\t"
+     "ldx [%%o1+8],%%o2\n\t"
+     "ldx [%%o2+%3],%%l0\n\t"
+     "ldx [%%o2+%3+8],%%l1\n\t"
+     "ldx [%%o2+%3+0x10],%%l2\n\t"
+     "ldx [%%o2+%3+0x18],%%l3\n\t"
+     "ldx [%%o2+%3+0x20],%%l4\n\t"
+     "ldx [%%o2+%3+0x28],%%l5\n\t"
+     "ldx [%%o2+%3+0x30],%%l6\n\t"
+     "ldx [%%o2+%3+0x38],%%l7\n\t"
+     "ldx [%%o2+%3+0x40],%%i0\n\t"
+     "ldx [%%o2+%3+0x48],%%i1\n\t"
+     "ldx [%%o2+%3+0x50],%%i2\n\t"
+     "ldx [%%o2+%3+0x58],%%i3\n\t"
+     "ldx [%%o2+%3+0x60],%%i4\n\t"
+     "ldx [%%o2+%3+0x68],%%i5\n\t"
+     "ldx [%%o2+%3+0x70],%%i6\n\t"
+     "ldx [%%o2+%3+0x78],%%i7\n\t"
+     /* Move to the next stack with the consistent registers atomically */
+     "mov %%o2,%%sp\n\t"
+     "ldx [%%o1],%%o2\n\t"
+     /* Since %o0-%o7 are marked as clobbered, values are safely overwritten
+	across the inline assembly.  %o0-%o7 will have meaningless values
+	after leaving the inline assembly. The only exception is %o0, which
+	serves as an argument to coco_main */
+     "ldx [%%o1+16],%%o0\n\t"
+     "jmpl %%o2,%%g0\n\t"
+     "nop\n\t"
+     "1:\n"
+     /* An assumption is made here; no input operand is assigned to %g1
+	nor %g2. It's the case for the currently avilable gcc's */
+     : : "r"(from),"r"(to),"r"(__tmp_sp),"i"(COCO_STACKBIAS)
+     : "g1","g2","o0","o1","o2","o3","o4","o5","o7","memory","cc");
+}
+
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  buf[0] = (void *)(func); \
+  buf[1] = (void *)COCO_PTR2SP(&(stack)[0]); \
+  buf[2] = (void *)(a0); \
+  stack[0] = 0; \
+  stack[1] = 0; \
+  stack[2] = 0; \
+  stack[3] = 0; \
+  stack[4] = 0; \
+  stack[5] = 0; \
+  stack[6] = 0; \
+  stack[7] = 0; \
+  stack[8] = 0; \
+  stack[9] = 0; \
+  stack[10] = 0; \
+  stack[11] = 0; \
+  stack[12] = 0; \
+  stack[13] = 0; \
+  stack[14] = COCO_PTR2SP(&(stack)[COCO_STACKADJUST]); \
+  stack[15] = 0xdeadc0c0deadc0c0; /* Dummy return address. */ \
+
+#else
+static inline void coco_switch(coco_ctx from, coco_ctx to)
+{
+  void *__tmp_stack[16] __attribute__((aligned (16)));
+  __asm__ __volatile__ 
+    ("ta 3\n\t"
+     "st %%sp,[%0+4]\n\t"
+     "mov %2,%%sp\n\t"
+     "set 1f,%%g1\n\t"
+     "st %%g1,[%0]\n\t"
+     "mov %1,%%o1\n\t"
+     "ld [%%o1+4],%%o2\n\t"
+     "ldd [%%o2],%%l0\n\t"
+     "ldd [%%o2+8],%%l2\n\t"
+     "ldd [%%o2+0x10],%%l4\n\t"
+     "ldd [%%o2+0x18],%%l6\n\t"
+     "ldd [%%o2+0x20],%%i0\n\t"
+     "ldd [%%o2+0x28],%%i2\n\t"
+     "ldd [%%o2+0x30],%%i4\n\t"
+     "ldd [%%o2+0x38],%%i6\n\t"
+     "mov %%o2,%%sp\n\t"
+     "ld [%%o1],%%o2\n\t"
+     "ld [%%o1+8],%%o0\n\t"
+     "jmpl %%o2,%%g0\n\t"
+     "nop\n\t"
+     "1:\n"
+     : : "r"(from),"r"(to),"r"(__tmp_stack)
+     : "g1","o0","o1","o2","o3","o4","o5","o7","memory","cc");
+}
+
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  buf[0] = (void *)(func); \
+  buf[1] = (void *)(stack); \
+  buf[2] = (void *)(a0); \
+  stack[0] = 0; \
+  stack[1] = 0; \
+  stack[2] = 0; \
+  stack[3] = 0; \
+  stack[4] = 0; \
+  stack[5] = 0; \
+  stack[6] = 0; \
+  stack[7] = 0; \
+  stack[8] = 0; \
+  stack[9] = 0; \
+  stack[10] = 0; \
+  stack[11] = 0; \
+  stack[12] = 0; \
+  stack[13] = 0; \
+  stack[14] = (size_t)&stack[COCO_STACKADJUST]; \
+  stack[15] = 0xdeadc0c0; /* Dummy return address. */ \
+
+#endif /* !define(__LP64__) */
+
+#endif /* arch check */
+
+#endif /* !(__GNUC__ >= 3 && !defined(COCO_USE_SETJMP)) */
+
+/* Try _setjmp/_longjmp with a patched jump buffer. */
+#ifndef COCO_MAKECTX
+#include <setjmp.h>
+
+/* Check for supported CPU+OS combinations. */
+#if defined(__i386) || defined(__i386__)
+
+#define COCO_STATE_HEAD		size_t arg0;
+#define COCO_SETJMP_X86(coco, stack, a0) \
+  stack[COCO_STACKADJUST-1] = 0xdeadc0c0;  /* Dummy return address. */ \
+  coco->arg0 = (size_t)(a0);
+
+#if __GLIBC__ == 2 && defined(JB_SP)		/* x86-linux-glibc2 */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf->__jmpbuf[JB_PC] = (int)(func); \
+  buf->__jmpbuf[JB_SP] = (int)(stack); \
+  buf->__jmpbuf[JB_BP] = 0; \
+  COCO_SETJMP_X86(coco, stack, a0)
+#elif defined(__linux__) && defined(_I386_JMP_BUF_H)	/* x86-linux-libc5 */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf->__pc = (func); \
+  buf->__sp = (stack); \
+  buf->__bp = NULL; \
+  COCO_SETJMP_X86(coco, stack, a0)
+#elif defined(__FreeBSD__)			/* x86-FreeBSD */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf->_jb[0] = (long)(func); \
+  buf->_jb[2] = (long)(stack); \
+  buf->_jb[3] = 0; /* ebp */ \
+  COCO_SETJMP_X86(coco, stack, a0)
+#define COCO_STACKADJUST	2
+#elif defined(__NetBSD__) || defined(__OpenBSD__) /* x86-NetBSD, x86-OpenBSD */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf[0] = (long)(func); \
+  buf[2] = (long)(stack); \
+  buf[3] = 0; /* ebp */ \
+  COCO_SETJMP_X86(coco, stack, a0)
+#define COCO_STACKADJUST	2
+#elif defined(__solaris__) && _JBLEN == 10	/* x86-solaris */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf[5] = (int)(func); \
+  buf[4] = (int)(stack); \
+  buf[3] = 0; \
+  COCO_SETJMP_X86(coco, stack, a0)
+#elif defined(__MACH__) && defined(_BSD_I386_SETJMP_H)	/* x86-macosx */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf[12] = (int)(func); \
+  buf[9] = (int)(stack); \
+  buf[8] = 0; /* ebp */ \
+  COCO_SETJMP_X86(coco, stack, a0)
+#endif
+
+#elif defined(__x86_64__) || defined(__x86_64)
+
+#define COCO_STATE_HEAD		size_t arg0;
+
+#define COCO_MAIN_PARAM \
+  int _a, int _b, int _c, int _d, int _e, int _f, lua_State *L
+
+#if defined(__solaris__) && _JBLEN == 8			/* x64-solaris */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf[7] = (long)(func); \
+  buf[6] = (long)(stack); \
+  buf[5] = 0; \
+  stack[0] = 0xdeadc0c0;  /* Dummy return address. */ \
+  coco->arg0 = (size_t)(a0);
+#endif
+
+#elif defined(PPC) || defined(__ppc__) || defined(__PPC__) || \
+      defined(__powerpc__) || defined(__POWERPC__) || defined(_ARCH_PPC)
+
+#define COCO_STACKADJUST	16
+#define COCO_MAIN_PARAM \
+  int _a, int _b, int _c, int _d, int _e, int _f, int _g, int _h, lua_State *L
+
+#if defined(__MACH__) && defined(_BSD_PPC_SETJMP_H_)	/* ppc32-macosx */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf[21] = (int)(func); \
+  buf[0] = (int)(stack); \
+  stack[6+8] = (size_t)(a0);
+#endif
+
+#elif (defined(MIPS) || defined(MIPSEL) || defined(__mips)) && \
+  _MIPS_SIM == _MIPS_SIM_ABI32 && !defined(__mips_eabi)
+
+/* Stack layout for o32 ABI. */
+#define COCO_STACKADJUST	8
+#define COCO_MAIN_PARAM		int _a, int _b, int _c, int _d, lua_State *L
+
+#if __GLIBC__ == 2 || defined(__UCLIBC__)	/* mips32-linux-glibc2 */
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf->__jmpbuf->__pc = (func); /* = t9 in _longjmp. Reqd. for -mabicalls. */ \
+  buf->__jmpbuf->__sp = (stack); \
+  buf->__jmpbuf->__fp = (void *)0; \
+  stack[4] = (size_t)(a0);
+#endif
+
+#elif defined(__arm__) || defined(__ARM__)
+
+#if __GLIBC__ == 2 || defined(__UCLIBC__)	/* arm-linux-glibc2 */
+#ifndef __JMP_BUF_SP
+#define __JMP_BUF_SP	((sizeof(__jmp_buf)/sizeof(int))-2)
+#endif
+#define COCO_PATCHCTX(coco, buf, func, stack, a0) \
+  buf->__jmpbuf[__JMP_BUF_SP+1] = (int)(func); /* pc */ \
+  buf->__jmpbuf[__JMP_BUF_SP] = (int)(stack); /* sp */ \
+  buf->__jmpbuf[__JMP_BUF_SP-1] = 0; /* fp */ \
+  stack[0] = (size_t)(a0);
+#define COCO_STACKADJUST	2
+#define COCO_MAIN_PARAM		int _a, int _b, int _c, int _d, lua_State *L
+#endif
+
+#endif /* arch check */
+
+#ifdef COCO_PATCHCTX
+#define COCO_CTX		jmp_buf
+#define COCO_MAKECTX(coco, buf, func, stack, a0) \
+  _setjmp(buf); COCO_PATCHCTX(coco, buf, func, stack, a0)
+#define COCO_SWITCH(from, to)	if (!_setjmp(from)) _longjmp(to, 1);
+#endif
+
+#endif /* !defined(COCO_MAKECTX) */
+
+#endif /* !defined(COCO_USE_UCONTEXT) */
+
+/* ------------------------------------------------------------------------ */
+
+/* Use inline asm or _setjmp/_longjmp if available. */
+#ifdef COCO_MAKECTX
+
+#ifndef COCO_STACKADJUST
+#define COCO_STACKADJUST	1
+#endif
+
+#define COCO_FILL(coco, NL, mainfunc) \
+{ /* Include the return address to get proper stack alignment. */ \
+  size_t *stackptr = &((size_t *)coco)[-COCO_STACKADJUST]; \
+  COCO_MAKECTX(coco, coco->ctx, mainfunc, stackptr, NL) \
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* Else fallback to ucontext. Slower, because it saves/restores signals. */
+#else /* !defined(COCO_MAKECTX) */
+
+#include <ucontext.h>
+
+#define COCO_CTX		ucontext_t
+
+/* Ugly workaround for makecontext() deficiencies on 64 bit CPUs. */
+/* Note that WIN64 (which is LLP64) never comes here. See above. */
+#if defined(__LP64__) || defined(_LP64) || INT_MAX != LONG_MAX
+/* 64 bit CPU: split the pointer into two 32 bit ints. */
+#define COCO_MAIN_PARAM		unsigned int lo, unsigned int hi
+#define COCO_MAIN_GETL \
+  lua_State *L = (lua_State *)((((unsigned long)hi)<<32)+(unsigned long)lo);
+#define COCO_MAKECTX(coco, NL, mainfunc) \
+  makecontext(&coco->ctx, mainfunc, 2, \
+    (int)(ptrdiff_t)NL, (int)((ptrdiff_t)NL>>32));
+#else
+/* 32 bit CPU: a pointer fits into an int. */
+#define COCO_MAKECTX(coco, NL, mainfunc) \
+  makecontext(&coco->ctx, mainfunc, 1, (int)NL);
+#endif
+
+#define COCO_FILL(coco, NL, mainfunc) \
+  getcontext(&coco->ctx); \
+  coco->ctx.uc_link = NULL;  /* We never exit from coco_main. */ \
+  coco->ctx.uc_stack.ss_sp = coco->allocptr; \
+  coco->ctx.uc_stack.ss_size = (char *)coco - (char *)(coco->allocptr); \
+  COCO_MAKECTX(coco, NL, mainfunc)
+
+#define COCO_SWITCH(from, to)	swapcontext(&(from), &(to));
+
+#endif /* !defined(COCO_MAKECTX) */
+
+
+/* Common code for inline asm/setjmp/ucontext to allocate/free the stack. */
+
+struct coco_State {
+#ifdef COCO_STATE_HEAD
+  COCO_STATE_HEAD
+#endif
+  COCO_CTX ctx;			/* Own context. */
+  COCO_CTX back;		/* Context to switch back to. */
+  void *allocptr;		/* Pointer to allocated memory. */
+  int allocsize;		/* Size of allocated memory. */
+  int nargs;			/* Number of arguments to pass. */
+  STACK_VGID			/* Optional valgrind stack id. See above. */
+};
+
+typedef void (*coco_MainFunc)(void);
+
+/* Put the Coco state at the end and align it downwards. */
+#define ALIGNED_END(p, s, t) \
+  ((t *)(((char *)0) + ((((char *)(p)-(char *)0)+(s)-sizeof(t)) & -16)))
+
+/* TODO: use mmap. */
+#define COCO_NEW(OL, NL, cstacksize, mainfunc) \
+{ \
+  void *ptr = luaM_malloc(OL, cstacksize); \
+  coco_State *coco = ALIGNED_END(ptr, cstacksize, coco_State); \
+  STACK_REG(coco, ptr, cstacksize) \
+  coco->allocptr = ptr; \
+  coco->allocsize = cstacksize; \
+  COCO_FILL(coco, NL, mainfunc) \
+  L2COCO(NL) = coco; \
+}
+
+#define COCO_FREE(L) \
+  STACK_DEREG(L2COCO(L)) \
+  luaM_freemem(L, L2COCO(L)->allocptr, L2COCO(L)->allocsize); \
+  L2COCO(L) = NULL;
+
+#define COCO_JUMPIN(coco)	COCO_SWITCH(coco->back, coco->ctx)
+#define COCO_JUMPOUT(coco)	COCO_SWITCH(coco->ctx, coco->back)
+
+#endif /* !COCO_USE_FIBERS */
+
+/* ------------------------------------------------------------------------ */
+
+#ifndef COCO_MIN_CSTACKSIZE
+#define COCO_MIN_CSTACKSIZE		(32768+4096)
+#endif
+
+/* Don't use multiples of 64K to avoid D-cache aliasing conflicts. */
+#ifndef COCO_DEFAULT_CSTACKSIZE
+#define COCO_DEFAULT_CSTACKSIZE		(65536-4096)
+#endif
+
+static int defaultcstacksize = COCO_DEFAULT_CSTACKSIZE;
+
+/* Start the Lua or C function. */
+static void coco_start(lua_State *L, void *ud)
+{
+  if (luaD_precall(L, (StkId)ud, LUA_MULTRET) == PCRLUA)
+    luaV_execute(L, L->ci - L->base_ci);
+}
+
+#ifndef COCO_MAIN_PARAM
+#define COCO_MAIN_PARAM		lua_State *L
+#endif
+
+#ifndef COCO_MAIN_DECL
+#define COCO_MAIN_DECL
+#endif
+
+/* Toplevel function for the new coroutine stack. Never exits. */
+static void COCO_MAIN_DECL coco_main(COCO_MAIN_PARAM)
+{
+#ifdef COCO_MAIN_GETL
+  COCO_MAIN_GETL
+#endif
+  coco_State *coco = L2COCO(L);
+  for (;;) {
+    L->status = luaD_rawrunprotected(L, coco_start, L->top - (coco->nargs+1));
+    if (L->status != 0) luaD_seterrorobj(L, L->status, L->top);
+    COCO_JUMPOUT(coco)
+  }
+}
+
+/* Add a C stack to a coroutine. */
+lua_State *lua_newcthread(lua_State *OL, int cstacksize)
+{
+  lua_State *NL = lua_newthread(OL);
+
+  if (cstacksize < 0)
+    return NL;
+  if (cstacksize == 0)
+    cstacksize = defaultcstacksize;
+  else if (cstacksize < COCO_MIN_CSTACKSIZE)
+    cstacksize = COCO_MIN_CSTACKSIZE;
+  cstacksize &= -16;
+
+  COCO_NEW(OL, NL, cstacksize, ((coco_MainFunc)(coco_main)))
+
+  return NL;
+}
+
+/* Free the C stack of a coroutine. Called from lstate.c. */
+void luaCOCO_free(lua_State *L)
+{
+  COCO_FREE(L)
+}
+
+/* Resume a coroutine with a C stack. Called from ldo.c. */
+int luaCOCO_resume(lua_State *L, int nargs)
+{
+  coco_State *coco = L2COCO(L);
+  coco->nargs = nargs;
+  COCO_JUMPIN(coco)
+#ifndef COCO_DISABLE_EARLY_FREE
+  if (L->status != LUA_YIELD) {
+    COCO_FREE(L)
+  }
+#endif
+  return L->status;
+}
+
+/* Yield from a coroutine with a C stack. Called from ldo.c. */
+int luaCOCO_yield(lua_State *L)
+{
+  coco_State *coco = L2COCO(L);
+  L->status = LUA_YIELD;
+  COCO_JUMPOUT(coco)
+  L->status = 0;
+  {
+    StkId base = L->top - coco->nargs;
+    StkId rbase = L->base;
+    if (rbase < base) {  /* Need to move args down? */
+      while (base < L->top)
+	setobjs2s(L, rbase++, base++);
+      L->top = rbase;
+    }
+  }
+  L->base = L->ci->base;  /* Restore invariant. */
+  return coco->nargs;
+}
+
+/* Get/set the default C stack size. */
+int luaCOCO_cstacksize(int cstacksize)
+{
+  int oldsz = defaultcstacksize;
+  if (cstacksize >= 0) {
+    if (cstacksize == 0)
+      cstacksize = COCO_DEFAULT_CSTACKSIZE;
+    else if (cstacksize < COCO_MIN_CSTACKSIZE)
+      cstacksize = COCO_MIN_CSTACKSIZE;
+    defaultcstacksize = cstacksize;
+  }
+  return oldsz;
+}
+
+#endif
--- /dev/null	1970-01-01 01:00:00 +0100
+++ lua-5.1.4-coco/src/lcoco.h	2009-09-08 14:00:00 +0200
@@ -0,0 +1,72 @@
+/*
+** Lua/Coco glue.
+** Copyright (C) 2004-2009 Mike Pall. See copyright notice in lcoco.c
+*/
+
+#ifndef lcoco_h
+#define lcoco_h
+
+#define LUACOCO_VERSION		"Coco 1.1.6"
+#define LUACOCO_VERSION_NUM	10106
+
+/* Exported C API to add a C stack to a coroutine. */
+LUA_API lua_State *lua_newcthread(lua_State *L, int cstacksize);
+
+/* Internal support routines. */
+LUAI_FUNC void luaCOCO_free(lua_State *L);
+LUAI_FUNC int luaCOCO_resume(lua_State *L, int nargs);
+LUAI_FUNC int luaCOCO_yield(lua_State *L);
+LUAI_FUNC int luaCOCO_cstacksize(int cstacksize);
+
+/* Forward declaration. */
+typedef struct coco_State coco_State;
+
+/* These are redefined below. */
+#undef LUAI_EXTRASPACE
+#undef luai_userstateopen
+/* luai_userstateclose unused */
+#undef luai_userstatethread
+#undef luai_userstatefree
+#undef luai_userstateresume
+#undef luai_userstateyield
+
+/* Use Windows Fibers (Win98+). */
+#if defined(_WIN32)
+
+/* Fibers allocate their own stack. The whole Coco state is in front of L. */
+struct coco_State {
+  void *fib;			/* Own fiber (if any). */
+  void *back;			/* Fiber to switch back to. */
+  int nargs;			/* Number of arguments to pass. */
+  int dummy_align;
+};
+
+#define L2COCO(L)		(&((coco_State *)(L))[-1])
+#define LHASCOCO(L)		(L2COCO(L)->fib)
+#define LUAI_EXTRASPACE		sizeof(coco_State)
+#define luai_userstateopen(L)	L2COCO(L)->fib = NULL
+#define luai_userstatethread(L,L1)	L2COCO(L1)->fib = NULL
+#define COCO_USE_FIBERS
+
+#else /* !defined(_WIN32) */
+
+/* The Coco state depends on the context switch method used. See lcoco.c. */
+/* It's stored at the end of the stack. Only need a pointer in front of L. */
+#define L2COCO(L)		(((coco_State **)(L))[-1])
+#define LHASCOCO(L)		(L2COCO(L))
+/* This wastes some space on 32 bit systems, but gets better alignment. */
+#define LUAI_EXTRASPACE		sizeof(LUAI_USER_ALIGNMENT_T)
+#define luai_userstateopen(L)	L2COCO(L) = NULL
+#define luai_userstatethread(L,L1)	L2COCO(L1) = NULL
+
+#endif /* !defined(_WIN32) */
+
+#define luai_userstatefree(L)	if (LHASCOCO(L)) luaCOCO_free(L)
+#define luai_userstateresume(L, nargs) \
+  if (LHASCOCO(L)) return luaCOCO_resume(L, nargs)
+#define luai_userstateyield(L, nresults) \
+  do { if (LHASCOCO(L)) { \
+    L->base = L->top - (nresults);  /* Protect stack slots below. */ \
+    return luaCOCO_yield(L); } } while (0)
+
+#endif
--- lua-5.1.4/src/lstate.h	2008-01-03 16:20:39 +0100
+++ lua-5.1.4-coco/src/lstate.h	2009-09-08 14:00:00 +0200
@@ -12,6 +12,9 @@
 #include "lobject.h"
 #include "ltm.h"
 #include "lzio.h"
+#ifndef COCO_DISABLE
+#include "lcoco.h"
+#endif
 
 
 
@@ -112,7 +115,6 @@
   int stacksize;
   int size_ci;  /* size of array `base_ci' */
   unsigned short nCcalls;  /* number of nested C calls */
-  unsigned short baseCcalls;  /* nested C calls when resuming coroutine */
   lu_byte hookmask;
   lu_byte allowhook;
   int basehookcount;
--- lua-5.1.4/src/lstate.c	2008-01-03 16:20:39 +0100
+++ lua-5.1.4-coco/src/lstate.c	2009-09-08 14:00:00 +0200
@@ -93,7 +93,7 @@
   resethookcount(L);
   L->openupval = NULL;
   L->size_ci = 0;
-  L->nCcalls = L->baseCcalls = 0;
+  L->nCcalls = 0;
   L->status = 0;
   L->base_ci = L->ci = NULL;
   L->savedpc = NULL;
@@ -205,7 +205,7 @@
   do {  /* repeat until no more errors */
     L->ci = L->base_ci;
     L->base = L->top = L->ci->base;
-    L->nCcalls = L->baseCcalls = 0;
+    L->nCcalls = 0;
   } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
   lua_assert(G(L)->tmudata == NULL);
   luai_userstateclose(L);
--- lua-5.1.4/src/ldo.c	2008-01-18 23:31:22 +0100
+++ lua-5.1.4-coco/src/ldo.c	2009-09-08 14:00:00 +0200
@@ -83,7 +83,7 @@
   L->base = L->ci->base;
   luaF_close(L, L->base);  /* close eventual pending closures */
   luaD_seterrorobj(L, status, L->base);
-  L->nCcalls = L->baseCcalls;
+  L->nCcalls = 0;
   L->allowhook = 1;
   restore_stack_limit(L);
   L->errfunc = 0;
@@ -419,22 +419,16 @@
   lua_lock(L);
   if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
       return resume_error(L, "cannot resume non-suspended coroutine");
-  if (L->nCcalls >= LUAI_MAXCCALLS)
-    return resume_error(L, "C stack overflow");
   luai_userstateresume(L, nargs);
-  lua_assert(L->errfunc == 0);
-  L->baseCcalls = ++L->nCcalls;
+  lua_assert(L->errfunc == 0 && L->nCcalls == 0);
   status = luaD_rawrunprotected(L, resume, L->top - nargs);
   if (status != 0) {  /* error? */
     L->status = cast_byte(status);  /* mark thread as `dead' */
     luaD_seterrorobj(L, status, L->top);
     L->ci->top = L->top;
   }
-  else {
-    lua_assert(L->nCcalls == L->baseCcalls);
+  else
     status = L->status;
-  }
-  --L->nCcalls;
   lua_unlock(L);
   return status;
 }
@@ -443,7 +437,7 @@
 LUA_API int lua_yield (lua_State *L, int nresults) {
   luai_userstateyield(L, nresults);
   lua_lock(L);
-  if (L->nCcalls > L->baseCcalls)
+  if (L->nCcalls > 0)
     luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
   L->base = L->top - nresults;  /* protect stack slots below */
   L->status = LUA_YIELD;
--- lua-5.1.4/src/lapi.c	2008-07-04 20:41:18 +0200
+++ lua-5.1.4-coco/src/lapi.c	2009-09-08 14:00:00 +0200
@@ -108,25 +108,20 @@
 
 
 LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
-  int i;
+  StkId f, t;
   if (from == to) return;
   lua_lock(to);
   api_checknelems(from, n);
   api_check(from, G(from) == G(to));
   api_check(from, to->ci->top - to->top >= n);
-  from->top -= n;
-  for (i = 0; i < n; i++) {
-    setobj2s(to, to->top++, from->top + i);
-  }
+  f = from->top;
+  t = to->top = to->top + n;
+  while (--n >= 0) setobj2s(to, --t, --f);
+  from->top = f;
   lua_unlock(to);
 }
 
 
-LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
-  to->nCcalls = from->nCcalls;
-}
-
-
 LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
   lua_CFunction old;
   lua_lock(L);
--- lua-5.1.4/src/lbaselib.c	2008-02-14 17:46:22 +0100
+++ lua-5.1.4-coco/src/lbaselib.c	2009-09-08 14:00:00 +0200
@@ -18,6 +18,9 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
+#ifndef COCO_DISABLE
+#include "lcoco.h"
+#endif
 
 
 
@@ -524,7 +527,6 @@
     return -1;  /* error flag */
   }
   lua_xmove(L, co, narg);
-  lua_setlevel(L, co);
   status = lua_resume(co, narg);
   if (status == 0 || status == LUA_YIELD) {
     int nres = lua_gettop(co);
@@ -573,10 +575,27 @@
 }
 
 
+#ifndef COCO_DISABLE
+static int luaB_cstacksize (lua_State *L)
+{
+  lua_pushinteger(L, luaCOCO_cstacksize(luaL_optint(L, 1, -1)));
+  return 1;
+}
+#endif
+
+
 static int luaB_cocreate (lua_State *L) {
+#ifdef COCO_DISABLE
   lua_State *NL = lua_newthread(L);
   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
     "Lua function expected");
+#else
+  int cstacksize = luaL_optint(L, 2, 0);
+  lua_State *NL = lua_newcthread(L, cstacksize);
+  luaL_argcheck(L, lua_isfunction(L, 1) &&
+                   (cstacksize >= 0 ? 1 : !lua_iscfunction(L, 1)),
+                1, "Lua function expected");
+#endif
   lua_pushvalue(L, 1);  /* move function to top */
   lua_xmove(L, NL, 1);  /* move function from L to NL */
   return 1;
@@ -609,6 +628,9 @@
   {"status", luaB_costatus},
   {"wrap", luaB_cowrap},
   {"yield", luaB_yield},
+#ifndef COCO_DISABLE
+  {"cstacksize", luaB_cstacksize},
+#endif
   {NULL, NULL}
 };
 
@@ -648,6 +670,10 @@
 LUALIB_API int luaopen_base (lua_State *L) {
   base_open(L);
   luaL_register(L, LUA_COLIBNAME, co_funcs);
+#ifndef COCO_DISABLE
+  lua_pushboolean(L, 1); 
+  lua_setfield(L, -2, "coco");
+#endif
   return 2;
 }
 
--- lua-5.1.4/src/Makefile	2008-01-19 20:37:58 +0100
+++ lua-5.1.4-coco/src/Makefile	2009-09-08 14:00:00 +0200
@@ -8,7 +8,7 @@
 PLAT= none
 
 CC= gcc
-CFLAGS= -O2 -Wall $(MYCFLAGS)
+CFLAGS= -O2 -Wall $(MYCFLAGS) $(COCOCFLAGS)
 AR= ar rcu
 RANLIB= ranlib
 RM= rm -f
@@ -18,14 +18,29 @@
 MYLDFLAGS=
 MYLIBS=
 
+# ++ Coco =========
+# Default: autodetect gccasm/setjmp/ucontext/fibers context switch method.
+COCOCFLAGS=
+# Force use of setjmp (instead of gccasm).
+#COCOCFLAGS= -DCOCO_USE_SETJMP
+# Force use of ucontext (instead of gccasm or setjmp).
+#COCOCFLAGS= -DCOCO_USE_UCONTEXT
+# Uncomment this if you want to disable support for Coco.
+#COCOCFLAGS= -DCOCO_DISABLE
+# -- Coco =========
+
 # == END OF USER SETTINGS. NO NEED TO CHANGE ANYTHING BELOW THIS LINE =========
 
 PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris
 
+# ++ Coco =========
+COCO_O= lcoco.o
+# -- Coco =========
+
 LUA_A=	liblua.a
 CORE_O=	lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o \
 	lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o  \
-	lundump.o lvm.o lzio.o
+	lundump.o lvm.o lzio.o $(COCO_O)
 LIB_O=	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o \
 	lstrlib.o loadlib.o linit.o
 
@@ -121,62 +136,67 @@
 # DO NOT DELETE
 
 lapi.o: lapi.c lua.h luaconf.h lapi.h lobject.h llimits.h ldebug.h \
-  lstate.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h \
-  lundump.h lvm.h
+  lstate.h ltm.h lzio.h lmem.h lcoco.h ldo.h lfunc.h lgc.h lstring.h \
+  ltable.h lundump.h lvm.h
 lauxlib.o: lauxlib.c lua.h luaconf.h lauxlib.h
-lbaselib.o: lbaselib.c lua.h luaconf.h lauxlib.h lualib.h
+lbaselib.o: lbaselib.c lua.h luaconf.h lauxlib.h lualib.h lcoco.h
+lcoco.o: lcoco.c lua.h luaconf.h lobject.h llimits.h lstate.h ltm.h \
+  lzio.h lmem.h lcoco.h ldo.h lvm.h lgc.h
 lcode.o: lcode.c lua.h luaconf.h lcode.h llex.h lobject.h llimits.h \
-  lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h lgc.h \
-  ltable.h
+  lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h lcoco.h \
+  ldo.h lgc.h ltable.h
 ldblib.o: ldblib.c lua.h luaconf.h lauxlib.h lualib.h
 ldebug.o: ldebug.c lua.h luaconf.h lapi.h lobject.h llimits.h lcode.h \
-  llex.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h \
-  lfunc.h lstring.h lgc.h ltable.h lvm.h
+  llex.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
+  lcoco.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h
 ldo.o: ldo.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
-  lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lparser.h lstring.h \
-  ltable.h lundump.h lvm.h
+  lzio.h lmem.h lcoco.h ldo.h lfunc.h lgc.h lopcodes.h lparser.h \
+  lstring.h ltable.h lundump.h lvm.h
 ldump.o: ldump.c lua.h luaconf.h lobject.h llimits.h lstate.h ltm.h \
-  lzio.h lmem.h lundump.h
+  lzio.h lmem.h lcoco.h lundump.h
 lfunc.o: lfunc.c lua.h luaconf.h lfunc.h lobject.h llimits.h lgc.h lmem.h \
-  lstate.h ltm.h lzio.h
+  lstate.h ltm.h lzio.h lcoco.h
 lgc.o: lgc.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
-  lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
+  lzio.h lmem.h lcoco.h ldo.h lfunc.h lgc.h lstring.h ltable.h
 linit.o: linit.c lua.h luaconf.h lualib.h lauxlib.h
 liolib.o: liolib.c lua.h luaconf.h lauxlib.h lualib.h
 llex.o: llex.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h ltm.h \
-  lzio.h lmem.h llex.h lparser.h lstring.h lgc.h ltable.h
+  lzio.h lmem.h lcoco.h llex.h lparser.h lstring.h lgc.h ltable.h
 lmathlib.o: lmathlib.c lua.h luaconf.h lauxlib.h lualib.h
 lmem.o: lmem.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
-  ltm.h lzio.h lmem.h ldo.h
+  ltm.h lzio.h lmem.h lcoco.h ldo.h
 loadlib.o: loadlib.c lua.h luaconf.h lauxlib.h lualib.h
 lobject.o: lobject.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h \
-  ltm.h lzio.h lmem.h lstring.h lgc.h lvm.h
+  ltm.h lzio.h lmem.h lcoco.h lstring.h lgc.h lvm.h
 lopcodes.o: lopcodes.c lopcodes.h llimits.h lua.h luaconf.h
 loslib.o: loslib.c lua.h luaconf.h lauxlib.h lualib.h
 lparser.o: lparser.c lua.h luaconf.h lcode.h llex.h lobject.h llimits.h \
-  lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h \
-  lfunc.h lstring.h lgc.h ltable.h
+  lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h lcoco.h \
+  ldo.h lfunc.h lstring.h lgc.h ltable.h
 lstate.o: lstate.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
-  ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h llex.h lstring.h ltable.h
+  ltm.h lzio.h lmem.h lcoco.h ldo.h lfunc.h lgc.h llex.h lstring.h \
+  ltable.h
 lstring.o: lstring.c lua.h luaconf.h lmem.h llimits.h lobject.h lstate.h \
-  ltm.h lzio.h lstring.h lgc.h
+  ltm.h lzio.h lcoco.h lstring.h lgc.h
 lstrlib.o: lstrlib.c lua.h luaconf.h lauxlib.h lualib.h
 ltable.o: ltable.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
-  ltm.h lzio.h lmem.h ldo.h lgc.h ltable.h
+  ltm.h lzio.h lmem.h lcoco.h ldo.h lgc.h ltable.h
 ltablib.o: ltablib.c lua.h luaconf.h lauxlib.h lualib.h
 ltm.o: ltm.c lua.h luaconf.h lobject.h llimits.h lstate.h ltm.h lzio.h \
-  lmem.h lstring.h lgc.h ltable.h
+  lmem.h lcoco.h lstring.h lgc.h ltable.h
 lua.o: lua.c lua.h luaconf.h lauxlib.h lualib.h
 luac.o: luac.c lua.h luaconf.h lauxlib.h ldo.h lobject.h llimits.h \
-  lstate.h ltm.h lzio.h lmem.h lfunc.h lopcodes.h lstring.h lgc.h \
+  lstate.h ltm.h lzio.h lmem.h lcoco.h lfunc.h lopcodes.h lstring.h lgc.h \
   lundump.h
 lundump.o: lundump.c lua.h luaconf.h ldebug.h lstate.h lobject.h \
-  llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h lundump.h
+  llimits.h ltm.h lzio.h lmem.h lcoco.h ldo.h lfunc.h lstring.h lgc.h \
+  lundump.h
 lvm.o: lvm.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
-  lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h ltable.h lvm.h
+  lzio.h lmem.h lcoco.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h ltable.h \
+  lvm.h
 lzio.o: lzio.c lua.h luaconf.h llimits.h lmem.h lstate.h lobject.h ltm.h \
-  lzio.h
+  lzio.h lcoco.h
 print.o: print.c ldebug.h lstate.h lua.h luaconf.h lobject.h llimits.h \
-  ltm.h lzio.h lmem.h lopcodes.h lundump.h
+  ltm.h lzio.h lmem.h lcoco.h lopcodes.h lundump.h
 
 # (end of Makefile)
